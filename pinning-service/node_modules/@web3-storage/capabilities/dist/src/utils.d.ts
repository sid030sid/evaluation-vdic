/**
 * Check URI can be delegated
 *
 * @param {string} [child]
 * @param {string} [parent]
 */
export function canDelegateURI(child?: string | undefined, parent?: string | undefined): {
    ok: {};
    error?: undefined;
} | {
    error: Types.Failure;
    ok?: undefined;
};
/**
 * Checks that `with` on claimed capability is the same as `with`
 * in delegated capability. Note this will ignore `can` field.
 *
 * @param {Types.ParsedCapability} child
 * @param {Types.ParsedCapability} parent
 */
export function equalWith(child: Types.ParsedCapability, parent: Types.ParsedCapability): {
    error: Types.Failure;
    ok?: undefined;
} | {
    ok: {};
    error?: undefined;
};
/**
 * @param {unknown} child
 * @param {unknown} parent
 * @param {string} constraint
 */
export function equal(child: unknown, parent: unknown, constraint: string): {
    error: Types.Failure;
    ok?: undefined;
} | {
    ok: {};
    error?: undefined;
};
/**
 *
 * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'
 *
 * @param {import('@ucanto/interface').Ability} parent
 * @param {import('@ucanto/interface').Ability} child
 */
export function canDelegateAbility(parent: import('@ucanto/interface').Ability, child: import('@ucanto/interface').Ability): boolean;
export const ProviderDID: import("@ucanto/core/schema").Schema<`did:web:${string}` & `did:${string}` & Types.Phantom<{
    protocol: "did:";
}>, any>;
export const SpaceDID: import("@ucanto/core/schema").Schema<`did:key:${string}` & `did:${string}` & Types.Phantom<{
    protocol: "did:";
}>, any>;
export const AccountDID: import("@ucanto/core/schema").Schema<`did:mailto:${string}` & `did:${string}` & Types.Phantom<{
    protocol: "did:";
}>, any>;
export function equalLink<T extends Types.ParsedCapability<"store/add" | "store/get" | "store/remove", Types.URI<"did:">, {
    link?: Types.Link<unknown, number, number, 0 | 1> | undefined;
}>>(claimed: T, delegated: T): Types.Result<{}, Types.Failure>;
export function checkLink(claimed: Types.UnknownLink, imposed: Types.UnknownLink | undefined, at: string): Types.Result<{}, Types.Failure>;
export function and<T>(result: Types.Result<T, Types.Failure>): {
    error: Types.Failure;
    ok?: undefined;
} | undefined;
import * as Types from '@ucanto/interface';
import { ok } from '@ucanto/validator';
//# sourceMappingURL=utils.d.ts.map